### 预编译
暗示全局变量：任何变量，未经声明就直接赋值，此变量为全局对象所拥有，一切声明的全局变量，全都是window的属性
+ 预编译发生在函数执行的前一刻
+ 预编译步骤：
  1. 创建AO对象（Activation Object）
  2. 找形参和变量声明，将变量和形参名作为AO属性名，值为 undefined
  3. 将实参值赋给形参
  4. 在函数体里找函数声明，将函数声明作为AO对象属性名，值赋予函数体

注意：if 条件下不能声明 function
``` javascript
  if(true){
    var a = 10;
    function b(){}  // 错误
  }

  typeof(a)  // 返回 "undefined"  字符串undefined
```


  ```javascript
    function fn(a){
      console.log(a)
      var a = 123
      console.log(a)
      function a(){}
      console.log(a)
      function b(){}
      console.log(b)
      function d(){}
    }

    fn(1)

    // 依次输出：
    function a(){}, 123, 123, function b(){}
  
  ```


1. 函数声明整体提升：函数无论在哪声明总是会提升到js最前面
2. 变量 声明提升，全局变量会将变量的声明提升到前面



### 作用域
1. 作用域：每个 JavaScript 函数都有一个对象，对象中有些属性我们可以访问，但有些属性我们无法访问，这些属性仅供JavaScript引擎获取，[[scope]] 就是其中一个。[[scope]] 指的就是我们所说的作用域，其中存储了运行期上下文的集合

2. 作用域链：[[scope]] 中所存储的执行期上下文对象的集合，这个集合呈链式链接，这种链式链接叫做作用域链

3. 执行期上下文：当一个函数执行时，会创建一个成为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的。所以多此调用一个函数会导致创建多个执行上下文，当函数执行完毕，创建的执行上下文会被销毁
  - 查找变量：从作用域链的顶端依次向下查找



``` javascript
  function a(){
    var num = 100
    function b(){
      num++
      console.log(num)
    }
    return b
  }

  var demo = a()
  demo()  // num = 101
  demo()  // num = 102
```


### 闭包
当内部函数被保存到外部时，将会生成闭包。如上，内部函数 b 被保存到外部，通过变量 demo 引用。
闭包会导致原有作用域链不释放，造成内存泄漏


闭包的作用：
1. 实实现公有变量，如函数累加器，上述例子，num 就是公有变量
2. 可以做缓存（存储结构）：下例子相当于存储了 food 变量
  ``` javascript
    function eater(){
      var food = ''
      var obj = {
        eat: function(){
          console.log(`I am eating ${food}`)
          food = ''
        },
        push: function(pushFood){
          food = pushFood
        }
      }
      return obj
    }

    var eater1 = eater()
    eater1.push('apple')
    eater1.eat()  // I am eating apple
  ```
3. 可以实现封装，属性私有化
  ``` javascript
  var inherit = (function(){
    var F = function (){}
    return function(Target, Origin){
      F.prototype = Origin.prototype
      Target.prototype = new F()
      Target.prototype.constructor = Target
      Target.prototype.uber = Origin.prototype
    }
  }())

  // 其中 var F 就相当于闭包的私有变量
  ```
4. 模块化开发，防止污染全局变量


闭包会导致多个执行函数共享一个共有变量，如果不是特殊需要，应防止这种情况发生


### 立即执行函数
1. 定义：此类函数没有声明，在一次执行后立即释放。适合做初始化工作。好处：执行完之后立即释放内存，不占用空间
2. 形式：
    ``` javascript
      (function(){

      }())

      var num = (function(a,b,c){
        return a + b + c * 2
      }(1,2,3))
      console.log(num)  // 9


      // 注意, 下面会报错，函数声明后加执行符号 () 会报错
      function test(){
        console.log(123)
      }()

      test() // 这样不会报错


      // 这样也不会报错，（1，2，3）不再是执行符号，所以不会报错
      function test(a,b,c){
        console.log(a + b + c)
      }(1,2,3)

      // 相当于
      function test(a,b,c){
        console.log(a + b + c)
      }
      
      (1,2,3)

    ```
3. 只有表达式才能被执行符号执行，函数声明不可以


逗号运算符：
var a = (1+1, 1-1)  // a = 0;
会将逗号后面的表达式的结果返回给变量

例题：
``` javascript
  var x = 1
  if(function f(){}){
    x += typeof(f)
  }
  console.log(x)  // 结果为 1undefined

  // if(function f(){}) 条件为真，会执行后面的语句，但函数声明被 （） 包着会变成表达式，f 就不是函数定义了，变成未经过声明的变量，但typeof 一个未经声明的变量是字符串 undefined
```


### 对象
1. 字面量形式
var obj = {
  name: 'pipilei',
  age: 18
}

// 构造函数形式
function Person(name,age){
  this.name = name
  this.age = age
  this.grade = 2015
}
var person1 = new Person('pipilei', 18)

2. 构造函数内部原理：
  1. 在函数体最前面隐式的加上 this = { __proto__ : 构造函数.prototype }
  2. 执行 this.xxx = xxx
  3. 隐式的返回 this

  function Person(name,age){
    this.name = name
    this.age = age
    this.grade = 2015
  }

  当 new Person() 时，相当于：
  function Person(name,age){
    var this = {}
    this.name = name
    this.age = age
    this.grade = 2015
    return this
  }

示例：
  function Person(name,age){
    this.name = name
    this.age = age
    this.grade = 2015
    return 123
  }
  var person1 = new Person('zhangsan',18)  // {name : 'zhangsan', age : 18, grade : 2015}
  var person2 = new Person('lisi',20)  // {name : 'lisi', age : 20, grade : 2015}

    function Person(name,age){
    this.name = name
    this.age = age
    this.grade = 2015
    return {}
  }
  var person1 = new Person('zhangsan',18)  // {}
  var person2 = new Person('lisi',20)  // {}

  + 总结：当 new 构造函数时，如果构造函数内部显式的返回原始值（Undefined,Null,Boolean,Number,String），则会忽略这条语句，相当于隐式返回 this，如果构造函数显示返回 非原始值，则会按照返回的类型返回


### 包装类
示例：
  var num = 4;
  num.length = 3; // 相当于 new Number(num).length = 3; 然后 delete，删除这个新创建的Number
  console.log(num.length) // 结果：undefined。 当再次访问 num.length 时，又相当于访问 new Number(num).length, 所以结果为 undefined

  var str = 'abcd'
  str.length = 2  // 相当于 new String(str).length = 2; delete
  console.log(str)  // 'abcd'
  console.log(str.length)  // 4, 相当于 new String(str).length,  而 length 属性是 String 对象自带的属性，所以结果为4，不是 undefined

笔试题：
  var str = 'adc'
  str += 1  // str = 'adc1'
  var test = typeof(str)  // test = 'string'
  if(test.length == 6){  // true
    test.sign = 'typeof 的返回结果可能为 String'  // 原始值赋属性会转成包装类，给包装类加属性，再 delete
  }
  console.log(test.sign)  // undefined


## 原型，原型链，call/apply
### 原型：
  1. 定义：  原型是function 对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象
  2. 利用原型的特点和概念，可以提取共有属性
  3. 对象如何查看原型：--> 隐式属性：__proto__
  4. 对象如何查看构造函数： --> constructor

  示例：
  function Person(){

  }
  Person.prototype.name = 'hehe'
  var person1 = new Person()  // person1.name = 'hehe'
  var person2 = new Person()  // person2.name = 'hehe'


  示例：
  function Person(){}
  Person.prototype.name = 'a'   // 相当于：Person{ var this = {__proto__ : Person.prototype } }
  var person = new Person()
  console.log(person.name)  // a
  Person.prototype.name = 'b'
  console.log(person.name)  // b

  示例：
  function Person(){}
  Person.prototype.name = 'a'
  var person = new Person()
  console.log(person.name)  // a
  Person.prototype = {
    name: 'b'
  }
  console.log(person.name)  // a

  示例：
  Person.prototype = {
    name : 'a',
    sayName : function(){
      console.log(this.name)
    }
  }
  function Person(){
    this.name = 'b'
  }

  var person = new Person()
  person.sayName() // b
  Person.prototype.sayName()  // a

  总结： a.sayName(), sayName 里面的 this 指向是：谁调用这个方法，this 就指向谁，person.sayName() 中，this 指向 person.name


### 原型链
如何构成原型链：
function Grand(){}
Grand.prototype.lastName = 'chen'
var grand = new Grand()

function Father(){ this.name = 'lei' }
Father.prototype = grand
var father = new Father()

function Son(){ this.hobby = 'play' }
Son.prototype = father()
var son = new Son()

原型链上属性的增删改查

绝大多数对象最终都会继承自 Object.prototype

Object.creat(原型 || null), 如果是 null ，则这个对象没有原型
var obj = Object.ceater(Son.prototype)

- 小知识：JavaScript 可正常计算的范围：小数点前 16 位，后 16 位

### call/apply
作用：改变 this 指向，可以借用别人的函数实现自己的功能
  示例：
  function Person(name,age,sex){
    this.name = name;
    this.age = age;
    this.sex = sex;
  }
  function Student(name,age,sex,grade){
    Person.call(this, name, age, sex)
    this.grade = grade
  }
  var student = new Student('pipilei', 18, 'male', 2015)

区别：后面传的参数形式不同: call 可以一个一个传参，apply 将参数放在 数组中
  Person.call(this, name, age, sex)
  Person.apply(this, [name, age, sex])

示例：
function Person(name,age){
  // 此时的 this 指向 window
  this.name = name
  this.age = age
}
var obj = {}
Person.call(obj, 'pipilei', 18)  // 当调用 Person.call(obj, 'pipilei', 19) 时， 会将 Person 函数内部的所有 this 替换成 obj，后面的参数正常传
console.log(obj) // { name : 'pipilei', age : 18 }


## 继承，命名空间，对象枚举
### 继承
继承发展史：
  1. 传统形式： 原型链，过多的继承了没用的属性
  2. 借用构造函数：不能继承借用的构造函数的原型，每次构造函数都要多走一个函数
  3. 共享原型：不能随便改动自己的原型
    示例：
    function Father(){}
    Father.prototype.name = 'chen'

    fnction Son(){}
    Son.prototype = Father.protoType
  4. 圣杯模式: 可以改动自己的原型，不影响共享的构造函数的原型
    function Father(){}
    Father.prototype.name = 'chen'

    funtion F(){}
    F.prototype = Father.prototype

    fnction Son(){}
    Son.prototype = new F()

    // 封装继承方法
    function inherit(Target, Origin){
      function F(){}
      F.prototype = Origin.prototype
      Target.prototype = new F()
    }

    // 但这样会继承 Origin 的 constructor
    // 修改
      function inherit(Target, Origin){
      function F(){}
      F.prototype = Origin.prototype
      Target.prototype = new F()
      Target.prototype.constructor = Target  // 使用自己的构造函数
      Target.prototype.uber = Origin.portotype // 储存继承自谁
    }


### 命名空间
命名空间作用：管理变量，防止污染全局，适用于模块化开发


### 对象的枚举
1. for in

2. hasOwnProperty: 判断对象属性是否是自己的属性，而不是原型链上的属性
  var obj = {
    name : 'pipilei',
    age : 18,
    __proto__ : {
      lastName : 'chen'
    }
  }
  for (var prop in obj){
    if(obj.hasOwnProperty(prop)){
      console.log(obj[prop])  // pipilei, 18
    }
  }

3. in : 判断属性是否是对象的属性，但无法区分是自己的属性还是原型继承过来的属性
  var obj {
    name : 'pipilei'
  }
  'name' in obj // true
  name in obj // 报错

4. instanceof
  A instanceof B：判断 A 对象是不是 B 构造函数构造出来的，理解：A 对象的原型链上有没有 B 的构造函数，如果有，返回 true， 没有返回 false
  function Person(){}
  var person = new Person()
  person instanceof Person // true
  person instanceof Object // true
  person instanceof Array // false


基础知识：typeof 返回结果： boolean, number, string, undefined, object, function


### this
1. 函数预编译过程： this --> window
2. 全局作用域中： this --> window
3. 如果在一个函数中有 this, 那么谁调用这个函数 this 指向谁
3. call/apply 函数可以改变this 指向
4. obj.function() 中的 this --> obj

例题：
var name = '222'
var a = {
  name : '111',
  say(){
    console.log(this.name)
  }
}

var fun = a.say
fun() // 222

a.say() // 111

var b = {
  name : '333',
  say(fun){
    fun()
  }
}

b.say(a.say) // 222
b.say = a.say
b.say()  // 333


### 函数中 arguments.callee
arguments.callee 相当于函数自身
function test() {
  console.log(arguments.callee)  // test(){ console.log(arguments.callee) }
  console.log(arguments.callee == test)  // true
}
test()

用处：在立即执行函数中计算 100 的阶乘
var result = (function(n){
  if(n == 1){
    return 1
  }
  return n * arguments.callee(n-1)
}(100))

### 函数的 caller： 当前函数的调用者
function test(){
  foo()
}
function foo(){
  console.log(foo.caller)
}

test() // 结果： test(){ foo() }


### 深度克隆方法
var obj = {
  name : 'pipilei',
  age : 18,
  sex : 'male'
}

// 浅克隆方法，如果克隆的属性值是引用值，不是原始值，那么 target 的属性改变， origin 的属性也会改变
function clone(origin, target){
  target = target || {}
  for(let prop in origin){
    target[prop] = origin[prop]
  }
  return target
}

// 深度克隆方法
function deepClone(origin, target){
  var target = target || {}
  var toString = Object.prototype.toString
  var arrStr = '[Object Array]'
  for(let prop in origin){
    if(origin.hasOwnProperty(prop)){
      if(origin[prop] !== 'null' && typeof(origin[prop]) == 'object'){
        <!-- if(toString.call(origin[prop]) == arrStr){
          origin[prop] = []
        }else{
          origin[prop] = {}
        } -->
        origin[prop] = (origin[prop] !== 'null' && typeof(origin[prop]) ? [] : {}
        deepClone(origin[prop], target[prop])
      }else{
        target[prop] = origin[prop]
      }
    }
  }
  return target
}


### 数组
1. 数组常用方法：
改变原数组：
push：往数组最后一项添加元素，可以添加多个值
pop：删除数组最后一个元素
shift：删除数组第一个元素
unshift：往数组最前面插入元素
reverse：翻转数组元素
splice：3个参数，第一个参数从数组的哪个位置开始，第二个参数为删除元素的数量，第三参数是要添加的元素。该方法返回被删除元素组成的数组
sort：对数组进行排序，默认按照 ASCII 码来排序
  var arr = [1,3,6,10,2]
  arr.sort()
  console.log(arr)  // [1, 10, 2, 3, 6]
  sort() 方法还可以传入一个函数，用例自定义比较的规则，传入函数规则：
    1. 必须写两个形参
    2. 看返回值：当返回值为负数时，那么前面的形参放在前面；返回值为正数时，后面的形参放在前面；返回0时不动
    sort(function(a,b){
      return a-b  // 正序排序
    })
  

  不改变原数组：
  concat，join，slice，toString

2. 类数组：
  1. 可以利用属性名模拟数组
  2. 可以动态的增长 length 属性
  3. 如果强行让类数组调用 push 方法，则会根据length属性值的位置进行属性的扩充

  var obj = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    'length': 3,
    'push': Array.prototype.push，
    'splice' : Array.prototype.splice
  }
  类数组的条件：
  1. 属性要为索引（数字）属性，必须有length 属性，最好加上 push 方法, 数组push 方法类似如下：
  Array.prototype.push = function(target){
    obj[obj.length] = target
    obj.length ++
  }


  例题：写一个函数，传递一个参数，判断该参数的类型
  function type(target){
    // 1. 分两类：原始值、引用值
    var template = {
      '[object Array]' : 'array',
      '[object Object]' : 'object',
      '[object Number]' : 'number-Object',
      '[object Boolean]' : 'boolean-Object',
      '[object String]' : 'string-Object',
    }
    if(target === null){
      return 'null'
    }
    if(typeof(target) === 'object'){
      var str = Object.prototype.toString.call(target)
      return template[str]
    }else {
      return typeof(target)
    }
  }

  例题：数组去重
  Array.prototype.unique = function () {
    let obj = {}
    var arr = []
    for (let index = 0; index < this.length; index++) {
      if (!obj[this[index]]) {
        obj[this[index]] = '#'
        arr.push(this[index])
      }
    }
    return arr
  }

  原始值和引用值的区别：
  1. 原始值存放在栈中，引用值存放在堆中
  2. 原始值不能有属性和方法，引用值可以有属性和方法

  [] == []  // false