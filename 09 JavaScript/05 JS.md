  ```javascript
  ```

### JavaScript 与 ECMAScript 的关系
+ ECMAScript 是 Javascript 的标准，描述了该语言的语法和基本对象
+ Javascript 是 ECMAScript 的实现，除了基本实现之外，还包括 BOM 和 DOM 操作

### Javascript 是一门解释性语言
+ 高级编程语言按照其运行的方式，可以分为：
  - 编译型语言：代码需要先编译成二进制文件，再执行
  - 解释型语言：一行一行读取，一行一行执行
+ 代表性语言：
  - 编译型语言：C/C++/Objective-C/Swift等
  - 解释型语言：Python/Javascript/MATLAB等
+ Java 语言是先编译成 class 文件，再解释

### 两个数字值交换的方法
1. 临时变量

2. 不使用临时变量：
  ```javascript
    var num1 = 100;
    var num2 = 200;

    num1 = num1 + num2;
    num2 = num1 - num2;
    num1 = num1 - num2;
  ```
3. a= a + b -(b = a);

4. b = a + (a = b)*0;

5. a = a*b;
   b = a/b;
   a = a/b;

6. a = a^b;
   b = a^b;
   a = a^b;


## 基本数据类型
### 字符串类型 String
+ 其他类型转成字符串类型：
  1. toString() 方法：null 类型和 undefined 类型没有 toString方法
  2. String(xxx)
  3. 通过 + 进行字符串拼接，其他数据类型在和 + 拼接是会自动转成 String 类型

### 布尔类型 Boolean
+ 其他类型转成布尔类型：使用 Boolean() 函数可以将其他类型转换成布尔类型
  - 转换成 false 的五种特殊值：""（空字符串）、0（包括0，-0）、undefined、null、NaN
  - 其他类型会被转换成 true

### 数字类型 Number
+ 数字的表示范围：
  - 最小值：Number.MIN_VALUE：这个值为：5e-324
  - 最大值：Number.MAX_VALUE：这个值为 1.7976931348623157e+308
+ NaN：即非数值（Not a Number）。是一个特殊的数值，JS 当中对数值进行计算时没有结果返回，则返回 NaN。 typeof NaN 返回 'number'
+ isNaN：用于判断一个数据是不是数字，不是数字返回 true，是数字返回 false

+ 将其他转成数字类型：但其他数据类型必须是可转成数字类型的，否则返回 NaN
  1. Number(xxx):
    ```javascript
      var str = "123";
      var num = Number(str);  // num = 123
    ```

  2. parseInt(string, radix)：将字符串转换成整数类型，radix 表示基数，这里可以理解成进制, 传2表示2进制，传8表示8进制
     parseFloat(string)：将字符串转换成小数类型
    - 如果第一个字符是数字或运算符号，那么就开始解析，直到遇到非数字字符，停止解析并得到解析结果
    - 如果第一个字符是非数字且非运算符号，则不解析得到结果 NaN

      ```javascript
        var str = '123.45';
        var num = parseInt(str);  // 返回 123

        var str1 = 'abc123';
        var num = parseInt(str1);  // 返回 NaN

        var str2 = '123abc';
        var num = parseInt(str2);  // 返回 123

        var str3 = '123.45.67';
        var num = parseFloat(str);  // 返回 123.45
      ```

### Null 类型
+ Null 类型也只有一个值：null
  - 当一个对象不需要在使用时，为了方便垃圾回收，可以将对象赋值为 null

### Undefined 类型
+ Undefined 类型只有一个值就是：undefined
  - 在使用 var 声明的变量但未对其进行初始化时，这个变量的值就是 undefined 
  - typeof 对没有初始化或没有声明的变量都会返回 undefined。但一个变量没有对其进行声明且没有赋值就直接使用会报错：Uncaught ReferenceError: xxx is not defined

### null 和 undefined 的关系
+ undefined 值实际上是由 null 值衍生出来的，所有如果比较 undefined 和 null 是否相等，会返回true。但严格等于的话返回false
  - undefined == null   // 返回true
  - undefined === null  //返回false
+ 但是转化成数字时，undefined 为 NaN，null 为 0

### vscode 开发小技巧：
+ 在写一个function时，鼠标放在()中可以查看该函数的参数要求（参数类型，参数个数）

### 运算符
1. 自增（++）、自减运算符（--）
  ```javascript
    var num = 100；
    num++;  //后置写法
    ++num;  //前置写法

    num--;  //后置写法
    --num;  //前置写法
  ```
  + 前置写法与后置写法的区别：参与运算时有区别：后置写法在参与运算时先取原来的值运算；前置写法在参与运算时先取++后的值参与运算
    ```javascript
    var num = 100;
    var result = num++ + 10;  // 110

    var num1 = 100;
    var result = ++num1 + 10;  // 111

    var a = 10;
    var b = a++ + a++;  
    console.log(a)  // 12
    console.log(b)  // 21

    var c = ++a + a++;  // 22
    var d = ++a + ++a;  // 23
  ```

2. 比较运算符
  + 非严格相等 == ：比较两个数值是否相等，不同类型的值在比较时先进行隐式类型转换
    - ToNumber(A) 尝试在比较前将参数 A 转换为数字，这与 +A（单目运算符+）的效果相同。
    - Object 类型与 Number，String，Boolean 类型比较时：ToPrimitive(obj通过尝试调用 obj 的obj.toString() 和 obj.valueOf() 方法，将参数 obj 转换为原始值（Primitive）。
    - Object 类型与 Null，Undefined 类型比较时：先调用 IsFalsy(obj) ，因此，IsFalsy(obj) 方法的值为 true ，当且仅当 obj 效仿 undefined。在其他所有情况下，一个对象都不会等于 undefined 或 null。
    - null == undefined 结果为 true

  + 严格相等 ===：
    - 在比较前都不进行隐式类型转换，如果类型不相同，返回 false，
    - 如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等
    - 如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的
    - NaN === NaN; //返回 false

  + Object.is(value1,value2)：这个方法是 ES6 新特性。Object.is的行为方式与三等号相同，但是对于NaN和-0和+0进行特殊处理，所以最后两个不相同

  + 关于比较时的隐式类型转换可以查看 MDN 文档[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness]

  ```javascript
    var num1 = 123;
    var num2 = '123';
    console.log(num == num2); //true  将字符串转成 Number 类型再进行比较

    var flag1 = true;
    var flag2 = 'true';
    console.log(flag1 == flag2); //false  将Boolean类型和 String 类型都先转成 Number 类型再比较，相当于 1 == NaN； 返回false

    var a = NaN;
    var b = NaN;
    console.log(a == b);   // false
    console.log(a === b);  // false
    console.log(Object.is(a,b))  // true,这种方法是 ES6 新特性。Object.is的行为方式与三等号相同，但是对于NaN和-0和+0进行特殊处理，所以最后两个不相同
  ```

3. 逻辑运算符
  + 逻辑与 &&，也可以称为 短路与，一旦遇到一个条件为 false，那么后面的条件不再判断
    - 逻辑与 && 的特殊用法：
    ```javascript
      var obj = {
        name:'pipilei',
        age: 18,
        eating(){
          console.log("吃东西")
        }
      }
      // 如果想要调用 eating 方法
      if(obj.eating){
        obj.eating()
      }
      // 可以写成
      obj.eating && obj.eating()
      // 原理：当执行逻辑与运算时，如果发现其中一个条件为 false，那么后续就不再判断，直接返回 false
    ```
  + 逻辑或 ||：也可以称为短路或，一旦遇到一个条件为 true，那么后面的条件不再判断
    - 逻辑或的特殊用法：
    ```javascript
      var obj = {
          name:'pipilei',
          age: 18,
          eating(){
            console.log("吃东西")
          }
        }
      // 逻辑或特殊用法：依次访问 obj 中的属性，如果有就返回属性值，没有访问下一个属性
      var result = obj.name || obj.age || obj.height
      console.log(result)
    ```
4. 运算符的优先级：下面优先级从高到低排列
  1. [], . , ()：字段访问，数组索引，函数调用和表达式分组。结合性：从左向右
  2. ++，--，-，~，!，delete，new，typeof，void：一元运算符，返回数据类型，对象创建，未定义的值。结合性：从右向左
  3. *，/，%：乘，除，取余。结合性：从左向右
  4. +，-：相加，相减，字符串拼接。结合性：从左向右
  5. <<，>>，>>>：左位移，右位移，无符号右移。结合性：从左向右
  6. <，<=，>，>=，instanceof：小于，小于等于，大于，大于等于，是否为特定类的实例。结合性：从左向右
  7. ==，!=，===，!==：相等，不相等，全等，不全等。结合性：从左向右
  8. &：按位与。结合性：从左向右
  9. ^：按位异或。结合性：从左向右
  10. |：按位或。结合性：从左向右
  11. &&：短路与（逻辑与）。结合性：从左向右
  12. ||：短路或（逻辑或）。结合性：从左向右
  13. ?：条件运算符。结合性：从右向左
  14. =，+=，-=，/=，%=，*=，&=，|=，^=，<，<=，>，>=，>>=：混合赋值运算符。结合性：从右向左
  15. . ：多个计算。结合性：按优先级计算，然后从右向左


### Switch 分支语句
+ case 穿透问题：
  - 一条case 语句结束后，会自动执行下一个case的语句。这种现象成为case穿透
  - 通过在每个case 的代码块后添加 break 关键字来解决这个问题

### 断点调试
1. 通过浏览器的开发者调试，在source选项中找对对应的JS文件 打断点
2. 在JS代码中加上 debugger

### 函数
1. arguments：该对象只存在于函数当中，该对象是一个类数组，会将函数传过来的实参一一放到该类数组中，通过下标访问的形式可以取到对应的实参。该参数和实参列表一一对应，但不是一个值 
  - 默认情况下，arguments 对象是所有（非箭头）函数中都可用的局部变量
  - 该对象中存放着调用者传入的所有参数，从 0 位置开始，依次存放
  - arguments 变量的类型是一个 object 类型，不是一个数组，但用法和数组的用法看起来类似，是一个类数组
  - 如果调用者传入的参数多于函数接受的参数，可以通过 arguments 去获取所有的参数


### 数组
+ forEach 方法：用于调用数组的每个元素，并将元素传递给回调函数
  - 语法：array.forEach(function(currentValue, index, arr), thisValue)
    + function(currentValue, index, arr)：回调函数，数组中每个元素都需要调用的函数，函数参数：
      1. currentValue：必需，当前元素
      2. index：可选，当前元素的索引值
      3. arr：可选，当前元素所属的数组对象
    + thisValue：可选。传递给函数的值一般用'this'值。如果这个参数为空，'undefined'会传递给'this'值




## JS 防抖和节流函数
### 防抖函数：
+ 只有在某个时间内，没有再次触发某个函数时，才真正的调用这个函数
  - 当事件触发时，相应的事件处理函数并不会立即执行，而是等待一定的事件
  - 当事件密集触发时，事件处理函数的调用会被频繁的推迟
  - 只有等待了一段事件也没有事件触发，才会真正的执行事件的处理函数

+ 防抖的应用场景：
  - 输入框中频繁的输入内容，搜索或者提交信息
  - 频繁的点击按钮，触发事件
  - 监听滚动事件，完成某些特定的操作
  - 用户缩放浏览器的 resize 事件

+ 防抖函数的核心思路：
  - 当触发一个函数时，并不会立即执行这个函数，而是会延迟一定时间（通过定时器来延迟函数的执行）
  - 如果在延迟时间内，再次触发了这个函数，那么取消上一次函数的执行（取消定时器）
  - 如果在延迟时间内，没有重新触发这个函数，那么这个函数就正常执行（执行传入的函数）

+ 代码实现：
  1. 最简单的防抖函数：
  ```javascript
    function debounce(fn,delay){
      var timer = null;
      return function(){
        if(timer){
          clearTimeout(timer)
        }
        timer = setTimeout(function(){
          fn();
        },delay)
      }
    }
  ```

  2. 优化参数和 this
    - 在 input 事件中会有参数传递，并且this的指向是当前元素节点，而目前 fn 的执行是一个独立的函数调用，this 指向 window
    - 目前fn 的执行是没有传递任何参数的，它需要将触发事件时传递的参数传递给 fn，而返回的 function 中的 arguments 正式我们需要的参数
    ```javascript
      function debounce(fn,delay) {  
        var timer = null;
        return function () {  
          // 获取 this 和 arguments。如果在事件中，this就是触发事件的元素，arguments 是 event 对象
          var _this = this;
          var _arguments = arguments;
          console.log(arguments)
          if(timer) clearTimeout(timer);
          timer = setTimeout(function(){
            fn.apply(_this, _arguments);
          },delay)
        }
      }
    ```
  
  3. 优化取消功能
    - 有时候，在等待执行的过程中，可能去要取消之前的操作：
      + 比如用户进行了搜索，但是还没有来得及发送搜索的情况下，退出了界面；当用户退出时，之前的操作就可以取消
      + 这里将 delay 时间延长，并增加一个点击按钮

    ```javascript
      function debounce(fn, delay){
        var timer = null;
        var handleFn = function () {  
          if(timer) clearTimeout(timer);

          var _this = this;
          var _arguments = arguments;
          timer = setTimeout(function () {  
            fn.apply(_this,_arguments)
          },delay)
        }

        handleFn.cancel = function () {  
          log('取消执行')
          if(timer) clearTimeout(timer);
        }
        return handleFn;
      } 

      var _searchChange = debounce(searchChange, 3000);
      searchEle.oninput = _searchChange;  // 输入框input事件
      cancelEle.onclick = function(e){    // 按钮取消事件
        _searchChange.cancel();
      } 
    ```

  4. 优化立即执行
    - 某些场景中，用户开始输入时的第一次是立即执行的，后面才需要等待
      + 可以让用户多传入一个参数：leading
        - leading 为 true，那么第一次就立即执行，后面的事件需要等待delay 时间执行
        - leading 为 false或者不传，就按照上面的防抖函数执行
      
    ``` javascript
      function debounce(fn, delay, leading){
        var timer = null;
        leading = leading || false;
        function handleFn(){
          if(timer) clearTimeout(timer);

          var _this = this;
          var _arguments = arguments;

          if(leading){
            // 通过一个变量来记录是否立即执行
            var isInvoke = false;
            if(!timer){
              fn.apply(_this,_arguments);
              isInvoke = true;
            }
            // 定时器通过修改timer来修改instant
            timer = setTimeout(function(){
              timer = null;
              if(!isInvoke){
                fn.apply(_this,_arguments);
              }
            },delay)
          }else{
            timer = setTimeout(function () {  
              fn.apply(_this, _arguments);
            },delay)
          }
        }

        handleFn.cancel = function () {  
          if(timer) clearTimeout(timer);
        }

        return handleFn;
      }
    ```

  5. 优化返回值
    - 有时候fn韩式执行结束之后还有返回值，如果我们希望拿到这个返回值该怎么办呢？
      + 先明确一个操作：内部执行fn 韩式大多数情况是异步执行的（在 setTimeout 中执行），所以是无法拿到返回值的
      + 可以通过ES6 的Promise 和 回调函数
    
    - Promise版本
    ```javascript
      function debounce(fn, delay, leading) {  
        var timer = null;
        function handleFn(){
          return new Promise((resolve, reject) => {
            if (timer) clearTimeout(timer);
            var _this = this;
            var _arguments = arguments;

            if (leading) {
              var isInvoke = false;
              if (!timer) {
                resolve(fn.apply(_this, _arguments));
                isInvoke = true;
              }
              timer = setTimeout(function () {
                timer = null;
                if (!isInvoke) {
                  resolve(fn.apply(_this, _arguments));
                }
              }, delay);
            } else {
              timer = setTimeout(function () {
                resolve(fn.apply(_this, _arguments));
              }, delay)
            }
          })
        }

        handleFn.cancel = function () {
          if (timer) clearTimeout(timer);
        }

        return handleFn;
      }

      var _searchChange = debounce(searchChange, 500,true);
      searchEle.oninput = _searchChange;
      searchEle.oninput(123).then(res => {
        log(res)
      })
    ```

    - 回调函数版本:
      + 因为这一次有多个可选参数，所以让调用者传入一个 option：
        1. leading：是否开始的回调直接执行一次
        2. result：函数类型，通过它来将结果回调出去

    ```javascript
        function debounce(fn,delay,option){
          var timer = null;

          // 设置option 默认值
          if(!option) option = {};
          var leading = option.leading || false;
          var result = option.result || null;

          function callFn(context, argument){
            var res = fn.apply(context, argument)
            if(result){
              result(res)
            }
          }

          function handleFn() {  
            if(timer) clearTimeout(timer)
            var _this = this;
            var _arguments = arguments;

            if(leading){
              var isInvoke = false;
              if(!timer){
                callFn(_this, _arguments)
                isInvoke = true;
              }
              timer = setTimeout(function () {
                timer = null;
                callFn(_this, _arguments)
              }, delay);
            }else{
              timer = setTimeout(function(){
                callFn(_this, _arguments)
              }, delay);
            }
          }

          handleFn.cancel = function () {
            if (timer) clearTimeout(timer);
          }
          return handleFn;
        }
    ```





### 节流函数
+ 在某个事件内，某个函数只能被触发一次（比如飞机大战游戏，按下空格发射一个子弹，但即使按下的频逻非常快，子弹也只会保持一定的频率来发射）

+ 节流的应用场景
  - 监听页面滚动事件
  - 鼠标移动事件
  - 用户频繁点击按钮操作
  - 游戏中的一些设计

+ 节流函数实现思路：采用时间戳的方式来完成
  - 使用一个 last 来记录上一次执行的时间
  - 每次准备执行前，获取一下当前时间 now：
  - 如果： now - last > interval
  - 那么执行函数，并且将 now 赋值给 last

+ 代码实现：
  1. 基本封装：
    ```javascript
      function throttle(fn, interval){
        var last = 0;
        return function () {  
          // this和 arguments
          var _this = this;
          var _arguments = arguments;

          var now = new Date().getTime();
          if(now - last > interval){
            fn.apply(_this, arguments);
            last = now;
          }
        }
      }
    ```
  2. 优化最后执行
    - 默认情况下，节流函数的最后一次是不会执行的，因为没有达到最终的时间，也就是条件 now - last > interval 是满足不了的，但是可以通过传入对应的参数来控制最后一次是可执行的
    